\documentclass[a4paper,12pt]{report}

\usepackage{alltt, fancyvrb, url}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{float}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}

% Questo commentalo se vuoi scrivere in inglese.
\usepackage[italian]{babel}

\usepackage[italian]{cleveref}

% Definizione stili per blocchi di codice
\lstdefinelanguage{bash}{
    keywords={cd, ls, mv, cp, rm, mkdir, rmdir, echo, cat, sudo, git, python3, pip, docker, npm},
    sensitive=true,
    morecomment=[l]{\#},
    alsoletter={-}
}
\lstdefinestyle{bash}{
    language=bash,
    basicstyle=\ttfamily\small,
    backgroundcolor=\color{gray!10},
    frame=single,
    breaklines=true,
    keywordstyle=\color{blue},
    commentstyle=\color{gray}\itshape,
}
\lstdefinestyle{java}{
    language=Java,
    basicstyle=\ttfamily\small,
    backgroundcolor=\color{gray!10},
    frame=single,
    breaklines=true,
    keywordstyle=\color{blue},
    commentstyle=\color{gray}\itshape,
    stringstyle=\color{orange},
}
\lstdefinestyle{scala}{
    language=Scala,
    basicstyle=\ttfamily\small,
    backgroundcolor=\color{gray!10},
    frame=single,
    breaklines=true,
    keywordstyle=\color{blue},
    commentstyle=\color{gray}\itshape,
    stringstyle=\color{orange},
}

\title{Relazione Assignment-02 \\ per l'esame \\ ``Programmazione Concorrente e distribuita''}
\author{Rattini Emiliano\\Giosuè Giocondo Mainardi\\Falconi Eleonora}

\date{\today}

\begin{document}

    \maketitle

    \tableofcontents

    \chapter{Analisi}
% A brief analsysis of the problem, focusing in particular aspects that are relevant from concurrent point of view.
    \section{Punto 1 - Asynchronous Library}

    L'obiettivo principale di questo assignment è lo sviluppo di uno strumento in grado di analizzare le dipendenze tra
    classi Java all'interno di un progetto software. In particolare, questa prima parte si concentra sulla progettazione
    e implementazione di una libreria asincrona, denominata \\ \texttt{DependencyAnalyzerLib}, che consente di effettuare
    un'analisi gerarchica delle dipendenze tra i file sorgente attraverso l'utilizzo di tre metodi asincroni.
    Dal punto di vista della programmazione concorrente, l’aspetto rilevante è rappresentato dall’uso del framework Vert.x,
    che consente un design asincrono. In particolare:
    \begin{itemize}
        \item Le operazioni bloccanti, come la lettura e il parsing dei file, sono eseguite fuori dal thread event-loop, preservando la reattività.
        \item Le Future e le composizioni permettono di strutturare flussi concorrenti e di parallelizzare l’analisi delle dipendenze, specialmente nella scansione ricorsiva del progetto e nella generazione dei report per ogni classe.
    \end{itemize}

    \section{Punto 2 - Reactive GUI}

    In questa parte di assignment lo scopo è sviluppare un'interfaccia che permetta di scegliere una cartella di progetto
    e di analizzare le sue dipendenze, rappresentandole in un grafo, sfruttando i paradigmi di programmazione reattiva,
    ed in particolare la libreria RxJava.
    In particolare l'interfaccia deve essere dinamica alla lettura delle dipendenze,
    aggiungendone man mano che vengono analizzate.


    \chapter{Design}
    Per l'espressività e la concisione si è deciso circa verso metà svolgimento
    del Punto 1 di adottare Scala come linguaggio
% A description of the adopted design, the strategy and architecture.
    \section{Punto 1 - Asynchronous Library}
    All'interno della classe \texttt{DependecyAnalyserLib} sono stati implementati questi tre metodi:
    \begin{itemize}
        \item \texttt{getClassDependencies(File classSrcFile)}: analizza un singolo file \emph{.java} e restituisce un oggetto ClassDepsReport che contiene l'elenco delle dipendenze importate.

        \item \texttt{getPackageDependencies(File packageSrcFolder)}: analizza tutti i file \emph{.java} contenuti in una cartella e restituisce un \texttt{PackageDepsReport}, che aggrega i report delle classi contenute.

        \item \texttt{getProjectDependencies(File projectSrcFolder)}: effettua una scansione ricorsiva di tutte le cartelle di un progetto Java e restituisce un \texttt{ProjectDepsReport}, che aggrega tutti i \texttt{PackageDepsReport}.
    \end{itemize}

    Tutti i metodi sono implementati in modo asincrono mediante le primitive offerte da \emph{Vert.x}, come \texttt{Future}, \texttt{compose} e \texttt{executeBlocking}, in modo da garantire scalabilità e reattività anche su progetti di grandi dimensioni.

    Il parsing dei file Java viene effettuato tramite la libreria \texttt{JavaParser}, che consente di estrarre in modo strutturato informazioni relative ai tipi dichiarati, ai parametri, ai tipi di ritorno, alle importazioni e ad altre componenti del linguaggio.

    L’architettura adottata favorisce modularità ed estendibilità: i risultati dell’analisi sono modellati tramite strutture dati immutabili (\texttt{ClassDepsReport}, \texttt{PackageDepsReport}, \texttt{ProjectDepsReport}) che riflettono la gerarchia logica del codice analizzato. Inoltre, l’approccio non bloccante permette l’elaborazione concorrente di più file, migliorando le prestazioni e l’efficienza dell’intero processo.

    \section{Punto 2 - Reactive GUI}
    \subsection{Model}
    Si è scelto di modellare il flusso di dipendenze attraverso i seguenti costrutti:
    \begin{itemize}
        \item\texttt{ClassInfo(String name, List<String> dependecies)}: composta da nome della classe e lista delle dipendenze
        \item\texttt{PackageInfo(String name, Observable<ClassInfo> classInfos)}: composta da nome e un Observable di ClassInfo,
                    che verrà valorizzato man mano che le classi vengono analizzate dal parser
    \end{itemize}
    In questo caso l'unico metodo esposto dall'API è \texttt{scanProject(File source)} che ritorna un
    \texttt{Observable<PackageInfo>}, sul quale la gui farà subscribe per disegnare a video un quadratino
    che rappresenta il package. Il \texttt{PackageInfo} risulterà pronto non appena l'oggetto verrà creato,
    nonostante le classi al suo interno non saranno state tutte analizzate.
    L'\texttt{Observable<ClassInfo>} all'interno di \texttt{PackageInfo} viene ritornato da una funzione privata
    \texttt{scanPackage(File source)}, che prende una cartella, legge tutti i file java presenti e attraverso
    \texttt{getClassInfo(File source)}, ritorna le \texttt{ClassInfo} per ogni file presente nel package.


    \chapter{Comportamento}
% A description of the behaviour of the system using one or multiple Petri Nets, choosing the propor level of abstraction.
    Petri Nets
    \section{Punto 1 - Asynchronous Library}
    \section{Punto 2 - Reactive GUI}

    \begin{figure}[h!]
    \centering
    \includegraphics[width=\textwidth]{UI.pdf}
    \caption{Rete di Petri per il flusso di esecuzione con input dell'utente.}
    \label{fig:UI}
    \end{figure}

    \begin{figure}[h!]
    \centering
    \includegraphics[width=\textwidth]{reactive_analysis.pdf}
    \caption{Rete di Petri per il flusso di esecuzione dell'analisi reattiva.}
    \label{fig:reactive_analysis}
    \end{figure}

    Per lanciare:
    \begin{lstlisting}[style=bash, caption={Avvio dello script}]
$ mvn clean javafx:run
    \end{lstlisting}
    \begin{lstlisting}[style=java, caption={Metodo Java asincrono}]
public CompletableFuture<String> fetchDataAsync() {
    return CompletableFuture.supplyAsync(() -> fetchFromApi());
}
    \end{lstlisting}
    \begin{lstlisting}[style=scala, caption={Esempio reattivo in Scala}]
val source = Source(1 to 10)
source.mapAsync(2)(x => Future(x * 2)).runWith(Sink.foreach(println))
    \end{lstlisting}


\end{document}
